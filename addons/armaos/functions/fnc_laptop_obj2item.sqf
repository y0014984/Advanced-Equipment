/*
 * Author: Root
 * Description: Converts a laptop object to an inventory item, preserving all state (filesystem, terminal, network, power).
 *
 * Arguments:
 * 0: _object <OBJECT> - The laptop object to convert
 * 1: _player <OBJECT> - The player picking up the laptop
 *
 * Return Value:
 * <BOOL> - True if successful, false otherwise
 *
 * Example:
 * [_laptop, player] call AE3_armaos_fnc_laptop_obj2item;
 *
 * Public: No
 */

params ["_object", "_player"];

private _itemClass = getText ((configOf _object) >> "ae3_item");

if (_itemClass == "") exitWith {
	hint "This laptop cannot be picked up into inventory.";
	false
};

private _buffer = missionNamespace getVariable ["AE3_LAPTOP_ITEM", createHashMap];

if (count _buffer > 511) exitWith {
	hint "Cannot carry more than 512 unique laptops at once.";
	false
};

// Get or assign a unique ID for this laptop
private _id = _object getVariable ["AE3_ITEM_ID", -1];
private _item = _itemClass + "_ID_";

if (_id == -1) then
{
	_id = 1;
	// Find available ID
	while {(_item + str _id) in _buffer} do
	{
		_id = _id + 1;
	};
	_object setVariable ["AE3_ITEM_ID", _id];
};

_item = _item + (str _id);

// Copy all object variables - this preserves ALL laptop state
// CRITICAL: Exclude variables containing TEXT (structured text) to prevent serialization warnings
// CRITICAL: Exclude all CODE references (functions) - they cannot be serialized and must be regenerated
// According to CLAUDE.md, never transmit TEXT via network - only raw STRING/ARRAY data
private _itemNamespace = createHashMap;
private _allVars = allVariables _object;

if (AE3_DebugMode) then {
	// DEBUG: Log what we're about to save with timestamp
	diag_log format ["[AE3 DEBUG] [%1] ========== laptop_obj2item: SAVING laptop %2 to item %3 ==========", time, _object, _item];
	diag_log format ["[AE3 DEBUG] [%1] Call stack: %2", time, diag_stacktrace];
	diag_log format ["[AE3 DEBUG] [%1] laptop_obj2item: Total variables on object: %2", time, count _allVars];

	// DEBUG: Check if critical flags exist on the object
	private _criticalFlags = ["AE3_interaction_laptopActionsAdded", "AE3_interaction_equipmentActionsAdded", "AE3_power_actionsAdded", "AE3_interaction_hasEquipmentAction"];
	{
		private _flagName = _x;
		private _flagValue = _object getVariable [_flagName, "NOT_FOUND"];
		diag_log format ["[AE3 DEBUG] [%1] laptop_obj2item: Flag check: %2 = %3 | In allVars: %4", time, _flagName, _flagValue, _flagName in _allVars];
	} forEach _criticalFlags;
};

private _excludedVars = [
	"AE3_terminal",                 // HashMap containing TEXT in AE3_terminalRenderedBuffer - causes serialization warnings
	"AE3_terminalRenderedBuffer",  // Contains TEXT - will be regenerated locally
	"AE3_terminalDialog",           // Display reference - not serializable
	"AE3_Links",                    // Command links - will be regenerated by fnc_link_init on deploy
	"AE3_computer_mutex",           // Runtime lock - should not persist
	"AE3_laptop_restored",          // Restoration flag - only used during deployment, don't save
	"AE3_UiOnTexActive",            // Runtime UI-on-Texture flag - texture must be re-set on deploy
	"AE3_UiOnTexDisplayName",       // Runtime UI-on-Texture display name - will be regenerated on deploy
	"AE3_interaction_hasEquipmentAction",  // Runtime ACE interaction flag - will be re-added by init
	"AE3_interaction_laptopActionsAdded",  // Runtime flag - will be re-added by init
	"AE3_interaction_equipmentActionsAdded",  // Runtime flag - will be re-added by init
	"AE3_power_actionsAdded",       // Runtime flag - will be re-added by init
	// All CODE references must be excluded - they cannot serialize and will be regenerated by init
	"AE3_interaction_fnc_open",     // CODE - will be re-assigned by init
	"AE3_interaction_fnc_close",    // CODE - will be re-assigned by init
	"AE3_interaction_fnc_openWrapper",  // CODE - will be re-assigned by init
	"AE3_interaction_fnc_closeWrapper", // CODE - will be re-assigned by init
	"AE3_interaction_fnc_openActionCondition",  // CODE - will be re-assigned by init
	"AE3_interaction_fnc_closeActionCondition", // CODE - will be re-assigned by init
	"AE3_power_fnc_turnOn",         // CODE - will be re-assigned by init
	"AE3_power_fnc_turnOff",        // CODE - will be re-assigned by init
	"AE3_power_fnc_standby",        // CODE - will be re-assigned by init
	"AE3_power_fnc_turnOnWrapper",  // CODE - will be re-assigned by init
	"AE3_power_fnc_turnOffWrapper", // CODE - will be re-assigned by init
	"AE3_power_fnc_standbyWrapper", // CODE - will be re-assigned by init
	"AE3_power_fnc_turnOnCondition",  // CODE - will be re-assigned by init
	"AE3_power_fnc_turnOffCondition", // CODE - will be re-assigned by init
	"AE3_power_fnc_standbyCondition"  // CODE - will be re-assigned by init
];

{
	// Skip excluded variables that contain TEXT or non-serializable types
	if (_x in _excludedVars) then {
		if (AE3_DebugMode) then {
			// DEBUG: Log excluded variables
			diag_log format ["[AE3 DEBUG] [%1] laptop_obj2item: EXCLUDING variable: %2", time, _x];
		};
	} else {
		private _value = _object getVariable _x;
		if (!isNil "_value") then {
			_itemNamespace set [_x, _value];
		};
	};
} forEach _allVars;

if (AE3_DebugMode) then {
	// DEBUG: Log what was actually saved
	diag_log format ["[AE3 DEBUG] [%1] laptop_obj2item: Saved %2 variables (excluded %3)", time, count _itemNamespace, (count _allVars) - (count _itemNamespace)];

	// DEBUG: Verify critical flags are NOT in the saved data
	private _criticalFlags = ["AE3_interaction_laptopActionsAdded", "AE3_interaction_equipmentActionsAdded", "AE3_power_actionsAdded", "AE3_interaction_hasEquipmentAction"];
	{
		private _flagName = _x;
		if (_flagName in _itemNamespace) then {
			diag_log format ["[AE3 DEBUG] [%1] laptop_obj2item: !!!!! ERROR! Flag %2 WAS SAVED despite being in exclusion list !!!!!", time, _flagName];
		} else {
			diag_log format ["[AE3 DEBUG] [%1] laptop_obj2item: Verified flag %2 is NOT in saved data (correct)", time, _flagName];
		};
	} forEach _criticalFlags;

	// DEBUG: Log ALL saved variable names to verify what's being saved
	diag_log format ["[AE3 DEBUG] [%1] laptop_obj2item: ===== COMPLETE LIST OF SAVED VARIABLES =====", time];
	{
		diag_log format ["[AE3 DEBUG] [%1] laptop_obj2item: Saved var: %2", time, _x];
	} forEach (keys _itemNamespace);
	diag_log format ["[AE3 DEBUG] [%1] laptop_obj2item: ===== END SAVED VARIABLES LIST =====", time];
};

// Store original object class type for recreation
_itemNamespace set ["AE3_OBJECT_TYPE", typeOf _object];

// Store position and orientation for potential re-deployment at same location
_itemNamespace set ["AE3_ORIGINAL_POS", getPosATL _object];
_itemNamespace set ["AE3_ORIGINAL_DIR", getDir _object];

// Save to global buffer (server-side only - do NOT broadcast to avoid TEXT serialization)
// The buffer will be synced on-demand when deploying via fnc_getRemoteVar
_buffer set [_item, _itemNamespace];
missionNamespace setVariable ["AE3_LAPTOP_ITEM", _buffer, false]; // Server-side only, no broadcast

// Add item to player inventory
[_player, _item, true] remoteExecCall ["CBA_fnc_addItem", _player];

// Show feedback to player - show "Laptop N" based on ID
hint format ["Packed Laptop %1 into inventory", _id];

// Delete the ground object
deleteVehicle _object;

true
